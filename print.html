<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>QEM Practical: Introduction to Automation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".\.\mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="prerequisites.html">Prerequisites</a></li><li class="chapter-item expanded "><a href="task_1.html"><strong aria-hidden="true">1.</strong> Task 1: Understanding what the microscope says</a></li><li class="chapter-item expanded "><a href="task_2.html"><strong aria-hidden="true">2.</strong> Task 2: Background Threading</a></li><li class="chapter-item expanded "><a href="task_3.html"><strong aria-hidden="true">3.</strong> Task 3: Reconstructing a Square Image from Small Spots</a></li><li class="chapter-item expanded "><a href="task_4.html"><strong aria-hidden="true">4.</strong> Task 4: Drawing a Circle</a></li><li class="chapter-item expanded "><a href="task_5.html"><strong aria-hidden="true">5.</strong> Task 5: Infinity Symbol</a></li><li class="chapter-item expanded "><a href="task_6.html"><strong aria-hidden="true">6.</strong> Task 6: Synchronization</a></li><li class="chapter-item expanded affix "><a href="functions_list.html">List of Microscope Related Functions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">QEM Practical: Introduction to Automation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Electron microscopes have always been an active subject of research, in
particular with the advent of new instrumentation like brighter electrons
sources, sensitive cameras (direct electron detection), phase plate and vortex
beam, aberration corrector, high collection angle EDX detector. This continuous
instrumental development has also led to the emergence of new methods of
observation by original techniques.</p>
<p>In parallel of these instrumental and methodological developments, automation of
the electron microscope is a growing research area.</p>
<p>Automation can be defined as the fact of repeating one or more processes during
a defined or indefinite number of iterations, in an identical way or by varying
one or more parameters. These processes can be related to the acquisition and/or
processing of images, with or without the control of the microscope. If the
implementation of automation can be complex, the possibilities offered in terms
of measurement, time saving and flexibility are without comparison.</p>
<p>Algorithms were first developed for focusing and astigmatism correction, leading
to computer-assisted alignment of higher order aberrations for
spherical-aberration-corrected TEM. Automation was extended to acquire
tomographic tilt series for cryo-microscopy, diffraction tomography, and
holographic tomography, and recording images of many specimen areas and defocus
values for single-particle analysis in cryo-microscopy. Further refinements
include object displacement and focus prediction to accelerate acquisition of
tilt series for shorter acquisition and less beam induced damage , online
reconstruction of tilt series for preliminary inspection of data at the
microscope, alignment of individual particles in images to correct for beam
induced movement, and more recently, development of routine analysis pipeline
coupled with the acquisition, enabling complete sample-tailored automated
acquisition, including specimen selection. For these applications, automation
was developed to acquire a specific sequence of images (or datasets) under a
chosen set of experimental conditions; for example, beam tilt and defocus for
aberration correction, or sample tilt for tomography. High numbers of images can
be easily acquired without requiring any operator interaction, leaving human
errors and fatigue out of the loop. Thanks to the computer-controlled execution,
automated sequences can also reduce the time the specimen is exposed to
electrons, which is important for beam-sensitive materials. A large part of
automation TEM has thus been developed for biological material studies which
require low-dose observations.</p>
<h2 id="aim"><a class="header" href="#aim">Aim</a></h2>
<p>The purpose of this tutorial is to introduce you to the principle and some
concepts, and let you imagine what you could do next. In a more detailed way, we
will learn how to communicate with the microscope, obtain or modify one of its
parameters, understand what the microscope returns. Then we will see how to
launch a background thread before seeing what to do to reconstitute an image
from the beam spot. Finally, we will try to draw a circle with the beam spot and
then execute two threads at the same time.</p>
<p>6 tasks will be followed during this practical. </p>
<h2 id="what-we-need"><a class="header" href="#what-we-need">What we need</a></h2>
<p>The automation for this practical requires different elements:</p>
<ul>
<li>a computer</li>
<li>a software for scripting. If this software has image processing and
acquisition functionalities, it becomes possible to automatize the recording
and processing of images while modifying one or several elements of the
microscope.</li>
<li>a detector (camera)</li>
<li>a connection to the microscope</li>
<li>a communication protocol with the microscope</li>
</ul>
<p><img src="diagram1.png" alt="" /></p>
<p>Here we will use Digital Micrograph (Gatan) (scripting, image acquisition and
communication with the microscope through the camera). Other software could be
used.</p>
<p>In the appendix are listed all generic functions (for all microscope models)
proposed by Digital Micrograph. The values of the variables are specific to each
microscope. You will note that many elements of the microscope are not
accessible (gun and imaging coils, intermediate and projector lenses,…) and that
probably some functions do not work depending on the microscope model or the
version of Digital Micrograph. To remedy this, you could develop the missing
functions yourself if the microscope manufacturer gives you access to the
communication protocol and an input. Some manufacturers have recently started
offering control functions for their microscopes.</p>
<p>In all the following tasks, we will only be interested in controlling the
position of the beam. But it is possible to modify many elements of the
microscope, individually or collectively (see appendix for others functions).</p>
<p>Before starting, please check that the Results window is open (in the menu:
Window -&gt; Floating Windows -&gt; Output and select the tab “Results”).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>If your computer is not connected to a microscope, install the <a
href="scripts/ToInstallLibrary.s" download>following script</a> as a library,
(if you don't know how to do it, you can refer to <a href="https://i3em.github.io/QEM2022-Advanced-Scripting-Practical/5-installing-scripts/part_3.html#admonition-installing-a-script-as-a-library">this
tutorial</a>).</p>
<p>You may remove this script after the practical using <a href="https://i3em.github.io/QEM2022-Advanced-Scripting-Practical/5-installing-scripts/part_3.html#admonition-removing-a-script">this
tutorial</a>.</p>
<p>For tasks 3 to 6, you will need to open the following <a href="scripts/View.dm4"
download>“View” image</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-1-understanding-what-the-microscope-says"><a class="header" href="#task-1-understanding-what-the-microscope-says">Task 1: Understanding what the microscope says</a></h1>
<p>Here the script you will use for task 1:</p>
<pre><code class="language-java">number xpos, ypos, xpos_mem, ypos_mem

EMGetBeamShift(xpos_mem, ypos_mem)

If (!OkCancelDialog(&quot;Move the beam with x and y buttons.\nPush on Ok when finished.&quot;))
	exit(0)

EMGetBeamShift(xpos, ypos)

Result(&quot;\nxpos mem = &quot; + xpos_mem + &quot;\typos mem = &quot; + ypos_mem + &quot;\n&quot;)
Result(&quot;xpos = &quot; + xpos + &quot;\typos = &quot; + ypos+&quot;\n&quot;)
Result(&quot;Delta x = &quot; + (xpos-xpos_mem) + &quot;\tDelta y = &quot; + (ypos-ypos_mem) + &quot;\n&quot;)
Result(&quot;Delta rho = &quot; + sqrt((xpos-xpos_mem)**2 + (ypos-ypos_mem)**2) + &quot;\n&quot;)

EMSetBeamShift(xpos_mem, ypos_mem)
</code></pre>
<p>Can you describe what this script does?</p>
<p>Execute this script in Digital Micrograph and note what is written in the Result
window.</p>
<p>What do you think these values are? To which parameters are they linked?</p>
<p>In general, there is no documentation associated with the control of the
microscope. To determine the response of each controllable element of the
microscope, you have to proceed to retro-engineering: under different conditions
(magnification, mode,...), measure the min and max bounds, and the minimum step.
For elements with 2 variables (in general x and y), check if both variables act
with the same weight.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-2-background-threading"><a class="header" href="#task-2-background-threading">Task 2: Background Threading</a></h1>
<p>Automation consists to repeat one or several instructions: the while or for loop
thus are mandatory. However, launching a process in a loop directly from a
&quot;simple&quot; script blocks all other processes such as the acquisition of images by
the camera and prevents any other access to Digital Micrograph.</p>
<p>For example, launch the following script, and try to interact with Digital
Micrograph (eg: open another file or move the window).</p>
<pre><code class="language-java">While (1&lt;2)
{
	// Date and time in the Result Window
	Result(DateStamp()+&quot;\n&quot;)

	// Wait 1s
	sleep(1)

	// Break the loop and stop the process
	If (ControlDown() &amp;&amp; ShiftDown()) break
}

Result(&quot;End of my loop\n&quot;)
</code></pre>
<p>To end the script, press <code>Control + Shift</code> on the keyboard for at least 1 second.</p>
<p>This problem can be solved if using a background thread. It corresponds to an
object created from a class of functions. The process that we wish to execute in
background corresponds to one of the functions (<code>MyFunction</code>) of the class
<code>Thread_Test</code>.</p>
<p>Open the following script and compare it to the previous one.</p>
<pre><code class="language-java">Class Thread_Test : object
{
	void init(object self) {}

	void MyFunction(object self)
	{
		While (1&lt;2)
		{
			// Date and time in the Result Window
			Result(DateStamp()+&quot;\n&quot;)

			// Wait 1s
			sleep(1)

			// Break the loop and stop the process
			If (ControlDown() &amp;&amp; ShiftDown()) break
		}

		Result(&quot;End of my loop\n&quot;)
	}
}

// Create an object from the class Thread_test
object MyObject = Alloc(Thread_Test)

// Launch the function
MyObject.MyFunction()
</code></pre>
<p>Execute the script: what do you observe? <em>(Stop the process by pressing on
<code>Control + Shift</code> for 1 second.)</em></p>
<p>Now replace <code>MyObject.MyFunction()</code> with <code>MyObject.StartThread(&quot;MyFunction&quot;)</code>
into the script and execute it now again. The process is running but you keep a
full control of others functionalities. A new execution will launch a second
process etc. However you have to keep in your mind that processes are running
and could create problems (memory, conflicts,…) : it is always necessary to
define a solution to stop or pause the processes automatically or manually, and
to keep a control and a view of all background processes you can launch.</p>
<p>Now you have all information for starting a full automation process!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-3-reconstructing-a-square-image-from-small-spots"><a class="header" href="#task-3-reconstructing-a-square-image-from-small-spots">Task 3: Reconstructing a Square Image from Small Spots</a></h1>
<div style="text-align: center"><img src="diagram2.svg"></div>
<p>The goal of this part is to reconstruct a square image by scanning the spot with
the beam shift coils in both camera directions, as a “STEM” based method.</p>
<p>Open the <a href="scripts/View.dm4" download>“View” image</a>, as well as the
following script, in Digital Micrograph:</p>
<pre><code class="language-java">Class Automation_Thread : object
{
	// Variables
	number i, j
	number count, size, nbpoints
	number xpos, ypos, xpos_mem, ypos_mem
	number wait

	image img, img_sum


	void Automation(object self)
	{
		// Square size
		size = 200

		// Wait time : delay between two successive instructions
		wait = 0.1

		// Nb of points per line or column
		nbpoints = 7

		// Acquisition of the inital beam position
		EMGetBeamShift(xpos_mem, ypos_mem)

		// Writing in the result window
		Result(&quot;\n&quot;+DateStamp()+&quot;: &quot;+xpos_mem+&quot;\t&quot;+ypos_mem+&quot;\n&quot;)

		// Acquisition of View, creation and display of the final image (img_sum)
		img := GetFrontimage()
		img_sum = img*0

		SetName(img_sum, GetName(GetFrontImage())+&quot; Sum Image&quot;)
		ShowImage(img_sum)


		// Modification of the beam position
		While (1&lt;2) // Infinite loop
		{


			If (ControlDown() &amp;&amp; ShiftDown()) break
		}

		// Go back to the initial beam position
		EMSetBeamShift(xpos_mem, ypos_mem)

		Result(&quot;End&quot;+&quot;\n&quot;)
	}
}


// Main function
// Creation and allocation of the object
object object_o = Alloc(Automation_Thread)


// Thread launch
object_o.StartThread(&quot;Automation&quot;)
</code></pre>
<p>You can see the structure of the process to complete. The variables correspond
to the size of the square, the number of points constituting each side, the
waiting time between each point. An image (<code>img_sum</code>) is created and will
represent the integration of all the recorded spots.</p>
<p>We ask you to complete the missing part in order to scan the spot from left to
right, and from top to bottom, in order to reconstruct a square image of defined
size and number of points, and centered at the initial beam position (here middle
of the image). </p>
<p>To do this, at some point in the program you will need to add the line to
integrate <code>img_sum</code>:</p>
<pre><code class="language-java">img_sum = Tert(img&gt; Mean(img), img, img_sum)
</code></pre>
<p>In addition, print <code>x</code> and <code>y</code> positions of the beam into the Result window, and
respect a waiting time between each spot. Don't forget to add the <code>Control + Shift</code> break in order to stop the process at any time.</p>
<details id="admonition-solution" class="admonition example">
<summary class="admonition-title">
<p>Solution</p>
<p><a class="admonition-anchor-link" href="task_3.html#admonition-solution"></a></p>
</summary>
<div>
<pre><code class="language-java">Class Automation_Thread : object
{
	// Variables
	number i, j
	number count, size, nbpoints
	number xpos, ypos, xpos_mem, ypos_mem
	number wait

	image img, img_sum


	void Automation(object self)
	{
		// Square size
		size = 200

		// Wait time : delay between two successive instructions
		wait = 0.2

		// Nb of points per line or column
		nbpoints = 7

		// Acquisition of the inital beam position
		EMGetBeamShift(xpos_mem, ypos_mem)

		// Writing in the result window
		Result(&quot;\n&quot;+DateStamp()+&quot;: &quot;+xpos_mem+&quot;\t&quot;+ypos_mem+&quot;\n&quot;)

		// Acquisition of View, creation and display of the final image (img_sum)
		img := GetFrontimage()
		img_sum = img*0

		SetName(img_sum, GetName(GetFrontImage())+&quot; Sum Image&quot;)
		ShowImage(img_sum)


		// Modification of the beam position
		While (1&lt;2) // Infinite loop
		{
			// For loop
			For (j=0; j&lt;nbpoints; j++)
			{
				For (i=0; i&lt;nbpoints; i++)
				{
					xpos = xpos_mem-size/2+size*i/(nbpoints-1)
					ypos = ypos_mem+size/2-size*j/(nbpoints-1)

					EMSetBeamShift(xpos, ypos)

					// Writing coordinates in the result window
					Result(xpos+&quot;\t&quot;+ypos+&quot;\n&quot;)

					sleep(wait)

					// We replace the modified part coming from the new acquisition
					img_sum = Tert(img&gt; Mean(img), img, img_sum)


					If (ControlDown() &amp;&amp; ShiftDown()) break
				}
				If (ControlDown() &amp;&amp; ShiftDown()) break
			}
			If (ControlDown() &amp;&amp; ShiftDown()) break
		}

		// Go back to the initial beam position
		EMSetBeamShift(xpos_mem, ypos_mem)

		Result(&quot;End&quot;+&quot;\n&quot;)
	}
}


// Main function
// Creation and allocation of the object
object object_o = Alloc(Automation_Thread)


// Thread launch
object_o.StartThread(&quot;Automation&quot;)
</code></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-4-drawing-a-circle"><a class="header" href="#task-4-drawing-a-circle">Task 4: Drawing a Circle</a></h1>
<p>Open the following script: </p>
<pre><code class="language-java">Class Automation_Thread : object
{
	// Variables
	number i, j
	number count, size, nbpoints
	number xpos, ypos, xpos_mem, ypos_mem
	number wait

	image img, img_sum


	void Automation(object self)
	{
		// Square size
		size = 100

		// Wait time : delay between two successive instructions
		wait = 0.1

		// Nb of points per line or column
		nbpoints = 7

		// Acquisition of the inital beam position
		EMGetBeamShift(xpos_mem, ypos_mem)

		// Writing in the result window
		Result(&quot;\n&quot;+DateStamp()+&quot;: &quot;+xpos_mem+&quot;\t&quot;+ypos_mem+&quot;\n&quot;)

		// Acquisition of View, creation and display of the final image (img_sum)
		img := GetFrontimage()
		img_sum = img*0

		SetName(img_sum, GetName(GetFrontImage())+&quot; Sum Image&quot;)
		ShowImage(img_sum)


		// Modification of the beam position
		While (1&lt;2) // Infinite loop
		{


			If (ControlDown() &amp;&amp; ShiftDown()) break
		}

		// Go back to the initial beam position
		EMSetBeamShift(xpos_mem, ypos_mem)

		Result(&quot;End&quot;+&quot;\n&quot;)
	}
}


// Main function
// Creation and allocation of the object
object object_o = Alloc(Automation_Thread)


// Thread launch
object_o.StartThread(&quot;Automation&quot;)
</code></pre>
<p>This script is identical to the previous one, except your work is now to draw a
circle with a defined radius and composed of <code>nbpoints</code>.</p>
<details id="admonition-solution" class="admonition example">
<summary class="admonition-title">
<p>Solution</p>
<p><a class="admonition-anchor-link" href="task_4.html#admonition-solution"></a></p>
</summary>
<div>
<pre><code class="language-java">Class Automation_Thread : object
{
	// Variables
	number i, j
	number count, size, nbpoints
	number xpos, ypos, xpos_mem, ypos_mem
	number wait

	image img, img_sum


	void Automation(object self)
	{
		// Square size
		size = 100

		// Wait time : delay between two successive instructions
		wait = 0.2

		// Nb of points per line or column
		nbpoints = 20

		// Acquisition of the inital beam position
		EMGetBeamShift(xpos_mem, ypos_mem)

		// Writing in the result window
		Result(&quot;\n&quot;+DateStamp()+&quot;: &quot;+xpos_mem+&quot;\t&quot;+ypos_mem+&quot;\n&quot;)

		// Acquisition of View, creation and display of the final image (img_sum)
		img := GetFrontimage()
		img_sum = img*0

		SetName(img_sum, GetName(GetFrontImage())+&quot; Sum Image&quot;)
		ShowImage(img_sum)


		// Modification of the beam position
		While (1&lt;2) // Infinite loop
		{
			For (i=0; i&lt;nbpoints; i++)
			{
				xpos = size*cos(2*pi()*i/nbpoints)
				ypos = size*sin(2*pi()*i/nbpoints)

				EMSetBeamShift(xpos, ypos)

				If (ControlDown() &amp;&amp; ShiftDown()) break

				// Writing in the result window
				Result(xpos+&quot;\t&quot;+ypos+&quot;\n&quot;)

				sleep(wait)

				// We replace the modified part coming from the new acquisition
				img_sum = Tert(img&gt; Mean(img), img, img_sum)
	
			}

			If (ControlDown() &amp;&amp; ShiftDown()) break
		}

		// Go back to the initial beam position
		EMSetBeamShift(xpos_mem, ypos_mem)

		Result(&quot;End&quot;+&quot;\n&quot;)
	}
}


// Main function
// Creation and allocation of the object
object object_o = Alloc(Automation_Thread)


// Thread launch
object_o.StartThread(&quot;Automation&quot;)
</code></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-5-infinity-symbol"><a class="header" href="#task-5-infinity-symbol">Task 5: Infinity Symbol</a></h1>
<div style="text-align: center"><img src="diagram3.svg"></div>
<p>In this part, we propose to draw the infinity symbol using the spot and a
“Circle thread” script. This symbol can be created from two identical circles
but with their centres offset horizontally by twice the radius. For this
purpose, each circle will be created from a background thread. Therefore, two
background threads must be launched in parallel, each corresponding to a circle
with a different centre. The starting point is the initial beam position given
by the red dot at the intersection of both circles, and your drawing should
follow the direction of the red arrows.</p>
<p>Open the following script:</p>
<pre><code class="language-java">Class Automation_Thread : object
{
	// Variables
	number count, radius, angle, nbpoints
	number xpos, ypos, xpos_mem, ypos_mem, xpos_delta, ypos_delta
	number wait
	image img, img_sum

	void init(object self, image img_init, image img_sum_init, number nbpoints_init,\
		number radius_init, number xpos_delta_init, number ypos_delta_init,\
		number wait_init)
	{
		img := img_init
		img_sum := img_sum_init

		nbpoints = nbpoints_init
		radius = radius_init
		xpos_delta = xpos_delta_init
		ypos_delta = ypos_delta_init
		wait = wait_init
	}

	void Automation(object self)
	{
		// Acquisition of the inital beam position
		EMGetBeamShift(xpos_mem, ypos_mem)

		// Writing in the result window
		Result(&quot;\n&quot;+DateStamp()+&quot;: &quot;+xpos_mem+&quot;\t&quot;+ypos_mem+&quot;\n&quot;)

		// Modification of the beam position
		While (1&lt;2) // Infinite loop
		{
			// For loop
			For (count=0; count&lt;abs(nbpoints); count++)
			{
				xpos = xpos_mem+xpos_delta+radius*cos(2*pi()*count/nbpoints)
				ypos = ypos_mem+ypos_delta+radius*sin(2*pi()*count/nbpoints)

				EMSetBeamShift(xpos, ypos)

				If (ControlDown() &amp;&amp; ShiftDown()) break

				// Writing in the result window
				Result(xpos+&quot;\t&quot;+ypos+&quot;\n&quot;)

				sleep(wait)

				// We replace the modified part coming from the new acquisition
				img_sum = Tert(img&gt; Mean(img), img, img_sum)
			}

			If (ControlDown() &amp;&amp; ShiftDown()) break
		}

		// Go back to the initial beam position
		EMSetBeamShift(xpos_mem, ypos_mem)


		Result(&quot;End&quot;+&quot;\n&quot;)
	}
}


// Variable initialization
number nbpoints, radius, xpos_delta, ypos_delta, wait
image img, img_sum

// Pointer on the view image
img := GetFrontImage()

// New image for the final result
img_sum = img*0
SetName(img_sum, GetName(img)+&quot; Sum Image&quot;)
ShowImage(img_sum)

// Radius : to be adjusted !
radius = 100

// Wait time : delay between two successive instructions
wait = 0.05

// Nb of points : 3 points = Triangle, 4 = Square, 5 Pentagone, etc.
// Many points for circle
nbpoints = 20

// If we want to move the circle centre
xpos_delta = 0
ypos_delta = 0

// Main function
// Creation and allocation of the object
object object_o = Alloc(Automation_Thread)

// Thread init
object_o.init(img, img_sum, nbpoints, radius, xpos_delta, ypos_delta, wait)

// Thread launch
object_o.StartThread(&quot;Automation&quot;)
</code></pre>
<p>This script allows you to modify the centre of the circle, the radius and the
direction of rotation independently. We advise you to analyze this script then
to manipulate it by modifying the variables to be able to control the position
of the centre of the circle, the starting point and the direction of rotation.</p>
<p>Finally, run two background threads in parallel by creating two different
objects from the same class to draw the infinity symbol as requested.</p>
<p>What do you observe? Explain what is going on.</p>
<details id="admonition-solution" class="admonition example">
<summary class="admonition-title">
<p>Solution</p>
<p><a class="admonition-anchor-link" href="task_5.html#admonition-solution"></a></p>
</summary>
<div>
<pre><code class="language-java">Class Automation_Thread : object
{
	// Variables
	number count, radius, angle, nbpoints
	number xpos, ypos, xpos_mem, ypos_mem, xpos_delta, ypos_delta
	number wait
	image img, img_sum

	void init(object self, image img_init, image img_sum_init, number nbpoints_init,\
		number radius_init, number xpos_delta_init, number ypos_delta_init,\
		number wait_init)
	{
		img := img_init
		img_sum := img_sum_init

		nbpoints = nbpoints_init
		radius = radius_init
		xpos_delta = xpos_delta_init
		ypos_delta = ypos_delta_init
		wait = wait_init
	}

	void Automation(object self)
	{
		// Acquisition of the inital beam position
		EMGetBeamShift(xpos_mem, ypos_mem)

		// Writing in the result window
		Result(&quot;\n&quot;+DateStamp()+&quot;: &quot;+xpos_mem+&quot;\t&quot;+ypos_mem+&quot;\n&quot;)

		// Modification of the beam position
		While (1&lt;2) // Infinite loop
		{
			// For loop
			For (count=0; count&lt;abs(nbpoints); count++)
			{
				xpos = xpos_mem+xpos_delta+radius*cos(2*pi()*count/nbpoints)
				ypos = ypos_mem+ypos_delta+radius*sin(2*pi()*count/nbpoints)

				EMSetBeamShift(xpos, ypos)

				If (ControlDown() &amp;&amp; ShiftDown()) break

				// Writing in the result window
				Result(xpos+&quot;\t&quot;+ypos+&quot;\n&quot;)

				sleep(wait)

				// We replace the modified part coming from the new acquisition
				img_sum = Tert(img&gt; Mean(img), img, img_sum)
			}

			If (ControlDown() &amp;&amp; ShiftDown()) break
		}

		// Go back to the initial beam position
		EMSetBeamShift(xpos_mem, ypos_mem)


		Result(&quot;End&quot;+&quot;\n&quot;)
	}
}


// Variable initialization
number nbpoints, radius, xpos_delta, ypos_delta, wait
image img, img_sum

// Pointer on the view image
img := GetFrontImage()

// New image for the final result
img_sum = img*0
SetName(img_sum, GetName(img)+&quot; Sum Image&quot;)
ShowImage(img_sum)

// Radius : to be adjusted !
radius = 100

// Wait time : delay between two successive instructions
wait = 0.2

// Nb of points : 3 points = Triangle, 4 = Square, 5 Pentagone, etc.
// Many points for circle
nbpoints = 20

// If we want to move the circle centre
xpos_delta = -radius
ypos_delta = 0

// Main function
// Creation and allocation of the object
object object_o = Alloc(Automation_Thread)

// Thread init
object_o.init(img, img_sum, -nbpoints, radius, xpos_delta, ypos_delta, wait)

// Thread launch
object_o.StartThread(&quot;Automation&quot;)


// Creation and allocation of the 2nd object
object object2_o = Alloc(Automation_Thread)

// Thread init
//void init(object self, image img, number nbpoints, number radius, number xpos_delta, number ypos_delta, number wait)
object2_o.init(img, img_sum, nbpoints, -radius, -xpos_delta, ypos_delta, wait)

// Thread launch
object2_o.StartThread(&quot;Automation&quot;)
</code></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-6-synchronization"><a class="header" href="#task-6-synchronization">Task 6: Synchronization</a></h1>
<p>The thread-object allows multiple parts of a script to be run on separate
threads. Those threads execute completely independent of each other. However,
often some form of communication between threads is needed. Either, because
multiple threads share a common resource (an image, a tag, a global variable or
object…) and mustn’t access/alter it at the same time, or because actions need
to be synchronized. A typical example would be a script which acquires data from
multiple detectors at different speed – each on a separate thread – and wants to
do something with all data once all detectors have returned their signal.
Another example would be a script which has a ‘controlling’ thread acting on
user input, and several ‘work threads’ performing calculations or other actions
which may be interrupted by user action. The scripting language offers a whole
range of ‘synchronizations objects’, but we will here demonstrate a ‘simple’
solution.</p>
<p>The critical-section object is the simplest of blocking-objects. Its goal is to
prevent different threads from accessing the same resources. The principle is
similar to that of multiple people sharing one TV remote control: Only one of
them can control the TV set, and the others have to wait until the remote
control is handled back before they can grab it.</p>
<p>A new critical-section object is created using <code>NewCriticalSection()</code>. A thread
can try grabbing it, using the <code>Acquire()</code> command. If the critical-section is
available, the command will return a script object and the critical-section
becomes unavailable until this object is removed from memory again. If the
critical-section is not available, a thread will wait until it becomes available
before continuing. If one wants to destroy a handle manually (before the end of
the routine is reached), one can do this by setting the handle-object <code>NULL</code>
explicitly. To summarize:</p>
<ul>
<li>Creation of the critical-section object to share between threads:
<pre><code class="language-java">object CS = NewCriticalSection()
</code></pre>
</li>
<li>Grab the critical-section if available, block if not:
<pre><code class="language-java">object CS_handle = CS.Acquire()
</code></pre>
</li>
<li>Release the critical-section:
<pre><code class="language-java">CS_handle = NULL
</code></pre>
</li>
</ul>
<p>Your work consists to introduce this blocking object in the previous script in
order to synchronize the thread and to draw the infinity symbol as requested in
task 5.</p>
<details id="admonition-solution" class="admonition example">
<summary class="admonition-title">
<p>Solution</p>
<p><a class="admonition-anchor-link" href="task_6.html#admonition-solution"></a></p>
</summary>
<div>
<pre><code class="language-java">object CS, CS_handle
CS = NewCriticalSection()


Class Automation_Thread : object
{
	// Variables
	number count, radius, angle, nbpoints
	number xpos, ypos, xpos_mem, ypos_mem, xpos_delta, ypos_delta
	number wait
	image img, img_sum

	void init(object self, image img_init, image img_sum_init, number nbpoints_init,\
		number radius_init, number xpos_delta_init, number ypos_delta_init,\
		number wait_init)
	{
		img := img_init
		img_sum := img_sum_init

		nbpoints = nbpoints_init
		radius = radius_init
		xpos_delta = xpos_delta_init
		ypos_delta = ypos_delta_init
		wait = wait_init
	}

	void Automation(object self)
	{
		// Acquisition of the inital beam position
		EMGetBeamShift(xpos_mem, ypos_mem)

		// Writing in the result window
		Result(&quot;\n&quot;+DateStamp()+&quot;: &quot;+xpos_mem+&quot;\t&quot;+ypos_mem+&quot;\n&quot;)

		// Modification of the beam position
		While (1&lt;2) // Infinite loop
		{
			CS_handle = CS.Acquire()

			// For loop
			For (count=0; count&lt;abs(nbpoints); count++)
			{
				xpos = xpos_mem+xpos_delta+radius*cos(2*pi()*count/nbpoints)
				ypos = ypos_mem+ypos_delta+radius*sin(2*pi()*count/nbpoints)

				EMSetBeamShift(xpos, ypos)

				If (ControlDown() &amp;&amp; ShiftDown()) break

				// Writing in the result window
				Result(xpos+&quot;\t&quot;+ypos+&quot;\n&quot;)

				sleep(wait)

				// We replace the modified part coming from the new acquisition
				img_sum = Tert(img&gt; Mean(img), img, img_sum)
			}

			If (ControlDown() &amp;&amp; ShiftDown()) break

			CS_handle = NULL
		}

		// Go back to the initial beam position
		EMSetBeamShift(xpos_mem, ypos_mem)


		Result(&quot;End&quot;+&quot;\n&quot;)
	}
}


// Variable initialization
number nbpoints, radius, xpos_delta, ypos_delta, wait
image img, img_sum

// Pointer on the view image
img := GetFrontImage()

// New image for the final result
img_sum = img*0
SetName(img_sum, GetName(img)+&quot; Sum Image&quot;)
ShowImage(img_sum)

// Radius : to be adjusted !
radius = 100

// Wait time : delay between two successive instructions
wait = 0.05

// Nb of points : 3 points = Triangle, 4 = Square, 5 Pentagone, etc.
// Many points for circle
nbpoints = 20

// If we want to move the circle centre
xpos_delta = -radius
ypos_delta = 0

// Main function
// Creation and allocation of the object
object object_o = Alloc(Automation_Thread)

// Thread init
object_o.init(img, img_sum, -nbpoints, radius, xpos_delta, ypos_delta, wait)

// Thread launch
object_o.StartThread(&quot;Automation&quot;)


// Creation and allocation of the 2nd object
object object2_o = Alloc(Automation_Thread)

// Thread init
//void init(object self, image img, number nbpoints, number radius, number xpos_delta, number ypos_delta, number wait)
object2_o.init(img, img_sum, nbpoints, -radius, -xpos_delta, ypos_delta, wait)

// Thread launch
object2_o.StartThread(&quot;Automation&quot;)
</code></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-of-microscope-related-functions"><a class="header" href="#list-of-microscope-related-functions">List of Microscope Related Functions</a></h1>
<h2 id="beam-shift"><a class="header" href="#beam-shift">Beam Shift</a></h2>
<pre><code class="language-java">// Get the current Beam Shift
void EMGetBeamShift(number &amp;shiftX, number &amp;shiftY)

// Set the beam shift to the values specified
void EMSetBeamShift(number beamshiftX, number beamshiftY)

// Change the beam shift by the amount specified in x and y
void EMChangeBeamShift(number xAmount, number yAmount)

// Get the Calibrated Beam Shift
void EMGetCalibratedBeamShift(number &amp;calbeamshiftX, number &amp;calbeamshiftY)

// Set the calibrated beam shift to the values specified
void EMSetCalibratedBeamShift( number calbeamshiftX, number calbeamshiftY)

// Changes the beam shift by the calibrated amounts supplied
void EMChangeCalibratedBeamShift(number xAmount, number yAmount)
</code></pre>
<h2 id="beam-tilt"><a class="header" href="#beam-tilt">Beam Tilt</a></h2>
<pre><code class="language-java">// Get the current Beam Tilts
void EMGetBeamTilt(number &amp;tiltX, number &amp;tiltY)

// Set the beam tilts to the values specified
void EMSetBeamTilt(number beamtiltX, number beamtiltY )

// Changes the beam tilt by the amount specified in x and y
void EMChangeBeamTilt(number xAmount, number yAmount)

// Get the calibrated beam tilt
void EMGetCalibratedBeamTilt(number caltiltX, number  caltiltY)

// Set the calibrated beam tilts to the values specified
void EMSetCalibratedBeamTilt(number  setcaltiltX, number setcaltiltY)

// Change the beam tilt by the calibrated amounts
void EMChangeCalibratedBeamTilt(number xAmount, number yAmount)
</code></pre>
<h2 id="image-shift"><a class="header" href="#image-shift">Image Shift</a></h2>
<pre><code class="language-java">// Get the current image shift x and y values
void EMGetImageShift(number &amp;getimageshiftx, number &amp;getimageshifty)

// Set the image shift to the values specified
void EMSetImageShift(number setimageshiftX, number setimageshiftY)

// Change the Image Shift by an uncalibrated amount
void EMChangeImageShift(number xAmount, number yAmount)

// Get the current calibrated image shifts
void EMGetCalibratedImageShift(number &amp;calimgshiftX, number &amp;calimgshiftY)

// Set the calibrated image shift to the values specified
void EMSetCalibratedImageShift(number setcalimageshiftX, number setcalimageshiftY)

// Change the image shift by a calibrated amount
void EMChangeCalibratedImageShift(number xAmount, number yAmount)
</code></pre>
<h2 id="condensor-stigmation"><a class="header" href="#condensor-stigmation">Condensor Stigmation</a></h2>
<pre><code class="language-java">// Get the current condensor stigmator values
void EMGetCondensorStigmation(number &amp;condstigx, number &amp;condstigy)

// Set the condensor stigmation values to the those specified
void EMSetCondensorStigmation(number setcondstigX, number setcondstigY)

// Change the Condensor Stigmation
void EMChangeCondensorStigmation(number xAmount, number yAmount)
</code></pre>
<h2 id="objective-stigmation"><a class="header" href="#objective-stigmation">Objective Stigmation</a></h2>
<pre><code class="language-java">// Change the (uncalibrated) objective stigmation
void EMChangeObjectiveStigmation(number xAmount, number yAmount)

// Get the current objective stigmation
void EMGetObjectiveStigmation(number &amp;getstigx, number &amp;getstigy)

// Set the objective stigmation value
void EMSetObjectiveStigmation(number setobjstigX, number setobjstigY)

// Get the current calibrated objective stigmation x and y values
void EMGetCalibratedObjectiveStigmation(number &amp;calobjstigX, number &amp; calobjstigY)

// Set the calibrated objective stigmation to the values specified
void EMSetCalibratedObjectiveStigmation(number setcalobjstigX, number setcalobjstigY )

// Change Calibrated Objective Stigmation
void EMChangeCalibratedObjectiveStigmation(number xAmount, number yAmount)
</code></pre>
<h2 id="brightness"><a class="header" href="#brightness">Brightness</a></h2>
<pre><code class="language-java">// Get the current Brightness
number EMGetBrightness()

// Set the brightness to the value specified
void EMSetBrightness(number brightness)
</code></pre>
<h2 id="focus"><a class="header" href="#focus">Focus</a></h2>
<pre><code class="language-java">// Get the current focus
number EMGetFocus()

// Set the focus to the value specified
number EMSetFocus(number setfocus)

// Change the focus - by an uncalibrated amount 
void EMChangeFocus(number amount)

// Get the current calibrated focus value
number EMGetCalibratedFocus()

// Set the calibrated focus to the value specified
void EMSetCalibratedFocus(number setcalfocus)

// Change the focus by the calibrated amount
void EMChangeCalibratedFocus(number amount)
</code></pre>
<h2 id="stage"><a class="header" href="#stage">Stage</a></h2>
<pre><code class="language-java">// Get the taggroup which (presumably) reports on the state of
// calibrations - (presumably) which are, and which are not, present.
TagGroup EMGetCalibrationStateTags()

// Read the current stage positions. The values read are selected
// by an axisflags parameter which can be any integer between 0 and
// 31 - see function for details
void EMGetStagePositions(number axisFlags, number &amp;stagepositionx, number &amp;stagepositiony, number &amp;stagepositionz, number &amp;stagealpha, number &amp;stagebeta)

// Set the current stage positions. The values read are selected by an axisflags parameter
// which can be any integer between 0 and 31 - see function for details
void EMSetStagePositions(number axisFlags, number stagepositionx, number stagepositiony, number stagepositionz, number stagealpha, number stagebeta)

// Get the current stage x and y positions
void EMGetStageXY(number &amp;stagexposition, number &amp;stageyposition)

// Set the stage x and y values to those specified
void EMSetStageXY(number bisetstagex, number bisetstagey)

// Get the current stage x position
number EMGetStageX()

// Set the stage x position to the value specified
void EMSetStageX(number monosetstagex)

// Get the current stage y position
number EMGetStageY()

// Set the stage y position to the value specified
void EMSetStageY(number monosetstagey)

// Get the current stage z position
number EMGetStageZ()

// Set the stage z position to the value specified
void EMSetStageZ(number monosetstagez)

// Get the current stage alpha (x) tilt
number EMGetStageAlpha()

// Set the stage alpha (x tilt) to the value specified
void EMSetStageAlpha(number setstagealpha)

// Get the current stage beta (y) tilt
number EMGetStageBeta()

// Set the stage beta (y tilt) to the value specified
void EMSetStageBeta(number setstagebeta)
</code></pre>
<h2 id="screen"><a class="header" href="#screen">Screen</a></h2>
<pre><code class="language-java">// Get the fluorescent screen position as an index
number EMGetScreenPosition()

// Set the screen position
void EMSetScreenPosition(number setscreenpos)
</code></pre>
<h2 id="high-tension"><a class="header" href="#high-tension">High Tension</a></h2>
<pre><code class="language-java">// Get the current high tension value
number EMGetHighTension()
</code></pre>
<h2 id="magnification"><a class="header" href="#magnification">Magnification</a></h2>
<pre><code class="language-java">// Get the current calibrated magnification
number EMGetCalibratedMag(String deviceLocation, TagGroup stateInfo, number &amp;calMag, number matchOptions)

// Get the index of the current magnification 
number EMGetMagIndex()

// Set the magnification index - each magnification has a numberical value eg 1- 40
void EMSetMagIndex(number setmagindex)

// Get the current magnification
number EMGetMagnification()
</code></pre>
<h2 id="field-of-view"><a class="header" href="#field-of-view">Field of View</a></h2>
<pre><code class="language-java">// Get the calibrated field of view for the selected camera location
number EMGetCalibratedFieldOfView(String deviceLocation, TagGroup stateInfo, number calFOV, number matchOptions)
</code></pre>
<h2 id="camera-length"><a class="header" href="#camera-length">Camera Length</a></h2>
<pre><code class="language-java">// Get the current camera length
number EMGetCameraLength()

// Get the calibrated camera length
number EMGetCalibratedCameraLength(String deviceLocation, TagGroup stateInfo, number calCL, number matchOptions)
</code></pre>
<h2 id="microscope-utilities"><a class="header" href="#microscope-utilities">Microscope Utilities</a></h2>
<pre><code class="language-java">// Get the microscope name
String EMGetMicroscopeName()

// Get the current illumination mode as a string
String EMGetIlluminationMode()

// Get a taggroup which contains the various illuminatin modes available
TagGroup EMGetIlluminationModes()

// Get the imaging optics mode
String EMGetImagingOpticsMode()

// Get the available imaging optics modes as a taggroup()
TagGroup EMGetImagingOpticsModes()

// Get the current microscope operation mode
String EMGetOperationMode()

// Get the current spot size
number EMGetSpotSize()

// Set the spot size to the values specified
void EMSetSpotSize(number spotSize)

// Update the calibration state
void EMUpdateCalibrationState()

// Return a boolean indicating if the microscope is ready
number EMIsReady()

// Wait until the microscope is ready
void EMWaitUntilReady()
</code></pre>
<h2 id="test-functions"><a class="header" href="#test-functions">Test functions</a></h2>
<pre><code class="language-java">// Test whether the microscope can return the camera length
number EMCanGetCameraLength()

// Test whether the microscope can return the HT value
number EMCanGetHighTension()

// Test whether the microscope can return the current illumination mode
number EMCanGetIlluminationMode()

// Test whether the microscope can return the current optics mode
number EMCanGetImagingOpticsMode()

// Test whether the microscope can return the current magnification
number EMCanGetMagnification()
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
